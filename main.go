package main

import (
	"log"
	"os"
	"path"
)

const (
	checkFunc        = "_go2check"
	handleBool       = "_go2handle"
	handleErr        = "_go2handleErr"
	varPrefix        = "_go2"
	extension        = ".go2"
	generatedComment = "// generated by go2gen; DO NOT EDIT"
)

func main() {
	/*
		ProcessFile("foo/foo.go2", "foo/foo.go3")
		return
	*/

	var dir string
	var err error
	if len(os.Args) > 1 {
		dir = os.Args[1]
	} else {
		dir, err = os.Getwd()
		if err != nil {
			log.Fatal(err)
		}
	}
	err = generate(dir)
	if err != nil {
		log.Fatal(err)
	}
}

func generate(dir string) error {
	pkg, err := parsePkg(dir)
	if err != nil {
		return err
	}

	err = transform(pkg)
	if err != nil {
		return err
	}

	/*
		err = pkg.applyComments()
		if err != nil {
			return err
		}
	*/

	for _, gf := range pkg.go2Files {
		w, err := os.Create(path.Join(dir, gf.name) + ".go")
		if err != nil {
			return err
		}
		_, err = w.WriteString(generatedComment + "\n\n")
		if err != nil {
			return err
		}
		str, err := gf.string()
		if err != nil {
			return err
		}
		_, err = w.WriteString(str)
		if err != nil {
			return err
		}
		//err = format.Node(w, pkg.fset, gf.f)
		//err = decorator.Fprint(w, gf.output)
	}

	/*
		dec := decorator.NewDecorator(fset)
		ai := astInfo{
			fset: fset,
			info: info,
			dec:  dec,
		}
		ac := astContext{
			astInfo: ai,
		}

		for _, pf := range fm {
			df, err := dec.DecorateFile(pf.File)
			if err != nil {
				return err
			}

			err = ac.convertFile(df, pf.checkMap, pf.handleMap)

			if err != nil {
				return err
			}

			w, err := os.Create(path.Join(dir, pf.name) + ".go")
			if err != nil {
				return err
			}
			_, err = w.WriteString(generatedComment + "\n\n")
			if err != nil {
				return err
			}
			err = ai.writeFileDst(w, df)
			if err != nil {
				return err
			}
		}
	*/

	return nil
}
